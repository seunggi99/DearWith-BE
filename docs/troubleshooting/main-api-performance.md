## 메인 페이지 API 성능 개선 (/api/main)

### 문제 상황
- 메인 페이지는 이벤트·아티스트·배너·추천/핫 이벤트 등 **다수의 연관 엔티티를 한 번에 조회**해야 했습니다.
- 기존 구현에서는 메인 목록 조회 후 연관 엔티티 접근 과정에서
  - **N+1 쿼리**가 발생하며 응답 시간이 증가했고,
  - fetch join 결과가 컬렉션에 중복으로 반영되면서(조인 row 중복) **불필요한 객체 로딩/후처리 비용**이 발생했습니다.
- 병목 가능성을 확인하기 위해 **k6 부하 테스트로 성능을 정량 측정**했습니다.

---

### 해결 방법

#### 1) N+1 제거: 조회 구조를 2단계로 재설계
- 메인 페이지에서 필요한 **이벤트 ID만 1차로 조회**한 뒤,
- `findWithMainPageRelationsByIdIn` 전용 쿼리로 다음 연관 엔티티를 **fetch join으로 일괄 로딩**하도록 분리했습니다.
  - 이벤트
  - 커버 이미지
  - 아티스트/그룹 및 프로필 이미지
- 조회 결과는 **ID 순서를 유지하도록 재정렬**해 기존 비즈니스 로직과 호환되도록 구성했습니다.
- 1차 조회: 메인 페이지에 노출할 이벤트 ID를 정렬·페이징 기준으로 조회
- 2차 조회: 조회된 ID 목록을 기준으로 연관 엔티티를 fetch join으로 일괄 로딩
#### 2) 컬렉션 중복 로딩 완화 + Batch Fetch 보조 최적화
- 다대다/일대다 연관관계에서 `List` → `LinkedHashSet`으로 변경해
  - 조인 결과 중복 row로 인한 **컬렉션 중복 엔트리 누적**을 방지하고, 입력 순서를 유지하면서 후처리 비용을 줄였습니다
  - 중복 제거 + 순서 보장을 동시에 만족
- 일부 Lazy 연관관계에는 `@BatchSize(size = 50)`를 적용해
  - 남아있는 Lazy 로딩 구간에서 **쿼리 호출 횟수를 묶음 단위로 제한**했습니다.

#### 3) 메인 페이지 캐시 전략 도입
- 읽기 빈도가 높은 “이번 달 기념일(아티스트 생일/그룹 데뷔)” 데이터에 대해 Redis 캐시를 적용했습니다.
- 이벤트/기념일 관련 데이터 변경 시 **캐시 무효화(invalidate)** 를 수행
  - 읽기 성능을 확보하면서도 데이터 정합성을 유지하도록 설계했습니다.
- 전체 캐시보다 변경 빈도가 낮고 조회 빈도가 높은 데이터만 선별 적용했습니다.
---

### 성과 (k6 부하 테스트 결과)
- 테스트 조건: VU 50 / 30초 / 약 1,500 요청 (동일 환경)
- 측정 지표: `http_req_duration`

| 지표 | 개선 전 | 개선 후 | 개선율 |
| --- | ---:| ---:| ---:|
| 평균 응답 시간 | 10.91 ms | 6.29 ms | 약 42% |
| p95 응답 시간 | 27.45 ms | 17.65 ms | 약 36% |
| 최대 응답 시간 | 156.10 ms | 44.18 ms | 약 72% |

- 조회 구조 개선과 캐시 전략을 병행해 **평균 지연과 최악 지연 구간(p95/최대)을 모두 안정화**했습니다.
- 요청당 실행 쿼리 수를 다수(N+1)에서 **고정된 소수 쿼리로 제한**해 트래픽 증가 시에도 성능이 선형적으로 악화되지 않도록 개선했습니다.