## WebView / Safari 인증 불일치 문제 해결

### 문제 상황
- Dearwith 서비스는 **JWT 기반 인증**을 사용하며,
    - 웹 환경에서는 **HttpOnly Cookie** 기반 인증을 적용하고 있었습니다.
- 그러나 iOS 앱(WebView) 환경에서 다음 문제가 발생했습니다.
    - Safari 정책 및 WebView 특성 차이로 인해 **쿠키가 정상적으로 전달되지 않음**
    - 동일한 API 호출임에도 **웹과 앱에서 인증 동작이 다르게 동작**
    - 앱 재실행 시 자동 로그인 실패, 401 인증 오류 등 불안정한 사용자 경험 발생
    - 앱 재실행 또는 백그라운드 복귀 시 WebView에서 쿠키가 전달되지 않아
      인증 토큰이 존재함에도 401 응답이 발생하는 문제가 확인됨
---

### 원인 분석
- iOS WebView는 Safari와 **쿠키 정책을 완전히 공유하지 않으며**
    - SameSite, ITP(Intelligent Tracking Prevention) 정책에 따라
      쿠키가 예고 없이 차단되거나 누락될 수 있음
- 특히:
    - 서드파티 쿠키 취급
    - 앱 재시작 시 쿠키 유지 여부
    - WebView ↔ Safari 간 저장소 분리  
      등의 제약으로 **쿠키 기반 인증만으로는 일관성 확보가 어려움**

→ 웹과 앱을 동일한 인증 전달 방식으로 처리하는 설계 자체가 문제라고 판단했다.

---

### 해결 방법

#### 1) 플랫폼별 인증 전달 방식 분리
- **웹(Web)**
    - 기존 구조 유지
    - HttpOnly Cookie 기반 JWT 인증
- **앱(WebView)**
    - 쿠키 사용을 제거
    - `Authorization: Bearer <JWT>` 헤더 기반 인증으로 분리

#### 2) 네이티브 브릿지 기반 토큰 전달
- 앱 로그인 시:
    - 토큰은 네이티브 영역(Keychain/Keystore)에 저장
    - WebView 로딩 시 **브릿지를 통해 토큰 전달**
- 서버는:
    - 요청 시 Authorization 헤더가 존재하면 **헤더 인증을 우선 처리**
    - 없을 경우 쿠키 인증으로 fallback

#### 3) 인증 정책은 단일하게 유지
- 인증 전달 방식만 분리하고, JWT 검증 로직, 권한 체크, 만료 처리 등 **인증 정책 자체는 공통으로 유지**
- 플랫폼 분기로 인한 인증 로직 중복을 최소화

---

### 개선된 인증 흐름

```text
[Web]
Browser
  ↓
Cookie 기반 JWT
  ↓
Server 인증

[App]
Native App
  ↓ (브릿지)
WebView
  ↓
Authorization Header
  ↓
Server 인증
```
---

### **성과**

- iOS WebView / Safari / 웹 환경 간 **인증 불일치 문제 완전 해소**
- 앱 재실행·백그라운드 복귀 시에도 **자동 로그인 안정화**
- 쿠키 정책 변화(Safari ITP)와 무관한 인증 구조 확보
- 플랫폼 특성을 반영하면서도 **단일 JWT 인증 정책 유지**

→ 구조 복잡도 증가 없이 확장성 확보