# **푸시 알림 시스템 아키텍처 설계**

*Firebase Cloud Messaging 기반 대규모 푸시 전송 및 운영 안정성 설계*

---

## **0. 개요**

Dearwith는 이벤트 공지, 시스템 알림 등 **실시간 사용자 반응이 중요한 서비스**로,

앱 환경(iOS / Android / WebView)을 고려한 **푸시 알림 시스템**이 필수였다.

본 문서는 단순히 “푸시를 보내는 기능”이 아니라,

- **대상자 규모가 커졌을 때의 전송 구조**
- **무효 토큰 누적에 따른 운영 리스크**
- **트랜잭션과 외부 I/O 분리**
- **장기 운영을 고려한 토큰 라이프사이클 관리**

를 중심으로 설계한 **푸시 알림 아키텍처**를 정리한 기록이다.

---

## **1. 기술 선택: Firebase Cloud Messaging (FCM)**

### **1.1 선택 배경**

- iOS / Android 모두 지원
- 안정적인 글로벌 메시지 전달 인프라
- Admin SDK를 통한 **멀티캐스트(배치) 전송 지원**
- 토큰 단위 실패 사유 제공 (UNREGISTERED 등)

→ **대규모 사용자 대상 푸시 전송에 적합**

---

## **2. 기본 구조**

### **2.1 푸시 전송 흐름 (개요)**
인앱 알림과 푸시 전송을 분리해,
푸시 실패가 비즈니스 흐름에 영향을 주지 않도록 설계했다.
```
[비즈니스 이벤트 발생]
   ↓
[Notification 생성 (DB)]
   ↓ (트랜잭션 커밋)
[푸시 전송 이벤트 발생]
   ↓
[PushNotificationService]
   ↓
[FCM Multicast 전송]
```

- **인앱 알림(Notification)** 은 항상 DB에 저장
- **푸시 알림**은 트랜잭션 커밋 이후 별도 흐름으로 전송

---

## **3. PushDevice 모델링 (토큰 관리의 핵심)**

푸시 토큰은 단순 문자열이 아니라 **운영 대상 리소스**로 취급했다.

### **3.1 PushDevice 핵심 필드**

- `userId`
- `deviceId`
- `fcmToken`
- `platform`
- `lastActiveAt`
- `enabled`
- `disabledAt`
- `disabledReason`

### **3.2 설계 의도**

- 토큰을 **즉시 삭제하지 않고 비활성화(disable)** 로 관리
- 실패 이력 및 재등록 흐름 추적 가능
- 장기 운영 시 사용자 단말·토큰 변화 추적 가능

---

## **4. 대량 전송 설계: Multicast 배치 전송**

### **4.1 문제 인식**

- 사용자 수 증가 시
- 토큰 단위 HTTP 요청 방식은 선형적으로 비용 증가
- 네트워크/전송 지연 리스크 확대

### **4.2 해결 전략**

- Firebase Admin SDK의 **MulticastMessage** 사용
- **최대 500 토큰 단위**로 배치 전송
- 토큰 리스트를 chunk로 분할하여 순차 처리

```
tokens (N)
 → 500개 단위 chunk
 → MulticastMessage 전송
 → BatchResponse 분석
```

### **4.3 효과**

- HTTP 호출 수 대폭 감소
- 대량 전송 시 처리 시간 안정화
- 서버 리소스 사용량 예측 가능

---

## **5. 실패 토큰 자동 정리 전략**

### **5.1 문제**

- UNREGISTERED / INVALID 토큰이 누적되면
    - 실패율 증가
    - 불필요한 전송 비용 발생
    - 로그 노이즈 증가

### **5.2 처리 방식**

- Multicast 응답에서 **개별 토큰 실패 원인 분석**
- 다음 경우 **영구 실패로 판단하여 disable 처리**
    - `UNREGISTERED`
    - `INVALID_ARGUMENT`

```
SendResponse 실패
 → MessagingErrorCode 확인
 → disable(token, reason)
```

### **5.3 장점**

- 실패 토큰 자동 정리
- 운영 개입 최소화
- 푸시 성공률 점진적 개선

---

## **6. 트랜잭션 분리 설계 (@TransactionalEventListener)**

### **6.1 문제**

알림 생성 로직 내부에서 푸시를 바로 전송하면:

- DB 트랜잭션이 외부 I/O에 종속됨
- FCM 지연/실패가 API 응답에 영향
- 롤백과 푸시 전송 간 정합성 문제 발생

### **6.2 해결**

- 알림 저장은 기존 트랜잭션 유지
- 푸시 전송은 **afterCommit 이벤트 리스너**에서 처리

```
[Notification 저장]
   ↓ commit
[푸시 전송 이벤트 처리]
```

### **6.3 효과**

- 핵심 API 응답 시간 안정화
- 외부 시스템 장애가 비즈니스 트랜잭션에 영향 없음
- 푸시 시스템을 독립적으로 확장 가능

---

## **7. 토큰 라이프사이클 정리 정책**

운영 안정성을 위해 토큰을 단계적으로 정리한다.

### **정책**

| 단계 | 기준 |
| --- | --- |
| disable 유지 | 90일 |
| soft delete | disable 후 90일 |
| hard delete | soft delete 후 90일 |
→ 즉시 삭제보다, 운영 분석과 장애 추적을 우선한 선택이었다.
### **의도**

- 최근 이력은 보존
- 과도한 DB 증가 방지
- 운영 비용과 추적 가능성의 균형

---

## **8. 설계 요약**

- FCM 기반 멀티캐스트 전송으로 대규모 푸시 처리
- 토큰을 리소스로 관리하여 운영 안정성 확보
- 실패 토큰 자동 비활성화
- 트랜잭션과 외부 I/O 분리
- 장기 운영을 고려한 라이프사이클 정책 적용

> 푸시 알림을 “기능”이 아니라
>
>
> **운영 가능한 시스템**으로 설계하는 것을 목표로 했다.
>