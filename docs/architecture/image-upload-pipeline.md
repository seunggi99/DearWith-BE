# **이미지 업로드 파이프라인 설계 기록**

*Presigned URL과 S3 상태 전이를 통한 정합성·운영성 확보*

---

## **0. 개요**

본 문서는 Dearwith 서비스에서 이미지 업로드를 설계·운영하며 발생한 문제와,

이를 해결하기 위해 도입한 **Presigned URL 기반 업로드**,

**S3 상태 전이(tmp → inline → trash)** 전략을 정리한 기록이다.

단순 파일 업로드 구현이 아니라,

**서버 부하 분산, DB–S3 정합성 확보, 장기 운영 안정성**을 핵심 목표로 설계를 진행했다.

> 이미지 업로드는  
> 기능 구현 문제가 아니라 **시스템 설계 및 운영 문제**였다.

---

## **1. 문제 정의: 이미지 업로드는 왜 어려운가**

이미지 업로드는 다음과 같은 특성을 가진다.

- DB 트랜잭션과 S3 업로드는 하나의 트랜잭션으로 묶을 수 없음
- 업로드 실패/중단 시 미사용 이미지가 쉽게 누적됨
- 대용량 파일 업로드는 서버 부하로 직결됨
- 이미지 교체·삭제 시 캐시, 롤백, 사용자 노출 문제가 발생함
- CDN 도입, 도메인 변경 등 환경 변화에 취약함

따라서 이미지 업로드는

**단순 CRUD가 아닌 상태 관리 + 라이프사이클 설계 문제**였다.

---

## **2. 업로드 방식 선택: Presigned URL**

### **2.1 고려한 대안**

- 서버 직접 업로드 (multipart/form-data)
- 서버 중계 업로드
- Presigned URL 기반 업로드

### **2.2 Presigned URL 선택 이유**

- 대용량 파일 전송을 서버에서 분리해 **부하 감소**
- 서버는 **권한 발급자**, 실제 파일 전송은 **클라이언트 → S3**
- 인증/비즈니스 로직과 파일 전송 로직 분리
- 업로드 범위·형식·시간을 제한한 **안전한 권한 위임 가능**

### **2.3 실제 권한 제어 방식**

Presigned URL 발급 시 다음 제약을 함께 적용했다.

- HTTP Method: PUT 전용
- Content-Type 제한 (이미지 MIME만 허용)
- TTL(유효 시간) 제한
- 업로드 경로 강제 (tmp/{domain}/...)

> Presigned URL은 “전체 S3 권한”이 아니라
> 제한된 시간·경로·형식만 허용하는 업로드 토큰


---

## **3. 이미지 Key 설계: URL을 저장하지 않은 이유**

### **3.1 S3 Key만 저장한 이유**

이미지 URL을 DB에 직접 저장하지 않고,

**S3 Key만 저장한 뒤 필요 시 URL을 조립**하는 방식을 선택했다.

이유는 다음과 같다.

- CloudFront 도입, 도메인 변경 등 환경 변화에 유연
- CDN/스토리지와 비즈니스 로직 간 결합도 감소
- URL 정책 변경 시 DB 마이그레이션, 비즈니스 코드 수정 불필요
- 장기 운영 관점에서 유지보수 비용 감소

### **3.2 Key 네이밍 규칙**

```text
tmp/{domain}/{year}/{month}/{uuid}-{filename}
inline/{domain}/{year}/{month}/{uuid}-{filename}
trash/{original-key}
```
- **domain**: image 사용 도메인 (event, review, user 등)
- **year/month**: 운영 및 정리 단위
- **uuid**: 중복 방지 및 추적성 확보

---

## **4. 이미지 파이프라인 구성**

### **4.1 전체 흐름**

```text
[Client]
  ↓ (Presigned URL)
[S3: tmp]
  ↓
[DB: Image(TMP)]
  ↓ (비즈니스 트랜잭션 성공)
[S3: inline]
  ↓
[비동기 variant 생성]
  ↓
[서비스 사용]
```

### **4.2 단계별 역할**

| **단계** | **역할** |
| --- | --- |
| tmp | 업로드 중·검증 전 임시 저장 영역 |
| inline | 서비스에서 실제 사용하는 이미지 |
| trash | 교체·삭제·실패 이미지 보관 영역 |

---

## **5. S3 상태 전이 모델 설계**

### **5.1 왜 상태 전이가 필요한가**

- S3는 트랜잭션 롤백이 불가능
- DB 실패 시 이미 업로드된 파일을 즉시 되돌릴 수 없음
- 교체·삭제 시 즉시 제거하면 복구 불가

→ **이미지를 “즉시 삭제”가 아닌 “상태 전이”로 관리**

### **5.2 상태 전이 흐름**
```text
tmp → inline → trash
```
- **tmp**
    - 업로드 직후 상태
    - 비즈니스 트랜잭션 실패 시 그대로 방치 가능
- **inline**
    - 실제 서비스에서 사용하는 이미지
    - 모든 API는 inline 기준으로 참조
- **trash**
    - 교체·삭제·실패 이미지
    - 즉시 삭제하지 않고 일정 주기로 정리

### **5.3 장점**

- DB–S3 간 **결과적 정합성(Eventual Consistency)** 확보
- 실수·장애 발생 시 복구 가능
- 운영 중 이미지 관리 및 장애 대응 안정성 향상

---

## **6. 이미지 교체·삭제 전략**

### **6.1 즉시 삭제를 하지 않은 이유**

- CDN 캐시 문제
- 트랜잭션 실패 시 복구 불가
- 사용자 화면 깜빡임 가능성

### **6.2 적용 전략**

- 교체/삭제 시 기존 이미지는 **trash로 이동**
- 신규 이미지만 inline으로 승격
- trash 영역은 배치 작업으로 정리

---

## **7. 설계 결과 요약**

- 서버 부하 없이 대용량 이미지 업로드 가능
- DB–S3 간 정합성 문제 최소화
- 이미지 교체·삭제 시 운영 안정성 확보
- 환경 변화(CDN, 도메인 변경)에 유연한 구조 확보
- 장기 서비스 운영을 고려한 이미지 라이프사이클 완성