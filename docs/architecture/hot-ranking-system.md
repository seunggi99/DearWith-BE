## 메인 페이지 API 성능 개선 (/api/main)

### 문제 상황

- 메인 페이지는 이벤트·아티스트·배너·추천/핫 이벤트 등 **다수의 연관 엔티티를 한 번에 조회**해야 했습니다.
- 기존 구현에서는 메인 목록 조회 후 연관 엔티티 접근 과정에서
  - **N+1 쿼리**가 발생하며 응답 시간이 증가했고,
  - fetch join 결과가 컬렉션에 중복으로 반영되면서(조인 row 중복) **불필요한 객체 로딩과 후처리 비용**이 발생했습니다.
- 병목 구간을 확인하기 위해 **k6 부하 테스트로 성능을 정량 측정**했습니다.

---

### 해결 방법

### 1) N+1 제거: 조회 구조를 2단계로 재설계

- 메인 페이지에서 필요한 **이벤트 ID만 1차로 조회**
- `findWithMainPageRelationsByIdIn` 전용 쿼리로 연관 엔티티를 **fetch join으로 일괄 로딩**
  - 이벤트
  - 커버 이미지
  - 아티스트/그룹 및 프로필 이미지
- 조회 결과는 **ID 순서를 유지하도록 재정렬**

→ 랭킹·정렬 기준을 유지하면서도

연관 엔티티 접근 과정에서 발생하던 **N+1 쿼리를 제거할 수 있었습니다.**

- 1차 조회: 메인 페이지 노출 기준에 맞춰 이벤트 ID를 정렬·페이징
- 2차 조회: ID 목록을 기준으로 연관 엔티티를 fetch join으로 일괄 조회

---

### 2) 컬렉션 중복 로딩 완화 + Batch Fetch 보조 최적화

- 다대다/일대다 연관관계에서 `List` → `LinkedHashSet`으로 변경
  - 조인 결과 중복 row로 인한 **컬렉션 엔트리 중복 누적을 방지**
  - 입력 순서를 유지하면서 중복 제거 가능
- 일부 Lazy 연관관계에 `@BatchSize(size = 50)` 적용

→ fetch join으로 해결되지 않는 Lazy 로딩 구간에서도

**쿼리 호출 횟수를 묶음 단위로 제한할 수 있었습니다.**

---

### 3) 메인 페이지 캐시 전략 도입

- 읽기 빈도가 높은 **이번 달 기념일(아티스트 생일/그룹 데뷔)** 데이터에 Redis 캐시 적용
- 이벤트·기념일 데이터 변경 시 **캐시 무효화(invalidate)** 수행
- 전체 캐시가 아닌, **변경 빈도는 낮고 조회 빈도가 높은 데이터만 선별 적용**

→ 읽기 성능을 확보하면서도

데이터 정합성을 유지할 수 있는 캐시 구조를 구성할 수 있었습니다.

---

### 성과 (k6 부하 테스트 결과)

- 테스트 조건: VU 50 / 30초 / 약 1,500 요청 (동일 환경)
- 측정 지표: `http_req_duration`

| 지표 | 개선 전 | 개선 후 | 개선율 |
| --- | --- | --- | --- |
| 평균 응답 시간 | 10.91 ms | 6.29 ms | 약 42% |
| p95 응답 시간 | 27.45 ms | 17.65 ms | 약 36% |
| 최대 응답 시간 | 156.10 ms | 44.18 ms | 약 72% |
- 조회 구조 재설계와 캐시 전략을 병행해

  **평균 지연과 최악 지연 구간(p95/최대)을 함께 줄일 수 있었습니다.**

- 요청당 실행 쿼리 수를 다수(N+1)에서 **고정된 소수 쿼리로 제한**해

  트래픽 증가 시에도 성능이 선형적으로 악화되지 않는 구조를 만들었습니다.